{"ast":null,"code":"const {\n  User\n} = require(\"../models/user\");\nconst bcrypt = require(\"bcryptjs\"); //pachet pt criptarea parolei cand inregistrezi userul\nconst jwt = require(\"jsonwebtoken\");\nconst crypto = require(\"crypto\");\nconst {\n  validationResult\n} = require(\"express-validator\");\nexports.signup = async (req, res, next) => {\n  const errors = validationResult(req);\n  try {\n    let user = await User.findOne({\n      email: req.body.email\n    });\n    if (!errors.isEmpty()) {\n      const error = new Error(\"Registration failed!\");\n      error.statusCode = 422;\n      error.data = errors.array();\n      throw error;\n    }\n    console.log(user);\n    if (user) {\n      return res.status(401).send({\n        message: \"User registered already\"\n      });\n    }\n\n    // if (!req.body.repeatPassword) {\n    //     const error = new Error(\"Repeated password cannot be empty\");\n    //     error.statusCode = 422;\n    //     throw error;\n    // }\n\n    // if (!req.body.password) {\n    //     const error = new Error(\"Password cannot be empty\");\n    //     error.statusCode = 422;\n    //     throw error;\n    // }\n\n    const buffer = await crypto.randomBytes(32);\n    const registryToken = buffer.toString(\"hex\");\n    const registryTokenExpiration = Date.now() + 3600000;\n    const name = req.body.name;\n    const email = req.body.email;\n    const password = req.body.password;\n    const hashedPassword = await bcrypt.hash(password, 12);\n    //user = new User({ name: name, email: email, password: password });\n    user = new User({\n      name: name,\n      email: email,\n      password: hashedPassword,\n      registryToken: registryToken,\n      registryTokenExpiration: registryTokenExpiration,\n      isAdmin: false,\n      isOwner: false\n    }); //pt a pune in baza de date\n\n    await user.save(); //pt a pune in baza de date\n\n    res.status(200).send(user._id);\n  } catch (error) {\n    next(error);\n  }\n};\nexports.login = async (req, res, next) => {\n  let loadedUser;\n  const errors = validationResult(req);\n  try {\n    const email = req.body.email;\n    const password = req.body.password;\n    const user = await User.findOne({\n      email,\n      registryToken: null\n    });\n    if (!errors.isEmpty()) {\n      const error = new Error(\"Login failed!\");\n      error.statusCode = 422;\n      error.data = errors.array();\n      throw error;\n    }\n    if (!user) {\n      const error = new Error(\"Email or password incorrect!\");\n      error.statusCode = 401;\n      throw error;\n    }\n    loadedUser = user;\n    const isEqual = await bcrypt.compare(password, user.password);\n    if (!isEqual) {\n      const error = new Error(\"Email or password incorrect!\");\n      error.statusCode = 401;\n      throw error;\n    }\n    const token = jwt.sign({\n      email: loadedUser.email,\n      userId: loadedUser.id\n    }, process.env.JWT_KEY, {\n      expiresIn: \"1h\"\n    });\n    res.status(200).json({\n      token: token,\n      userId: loadedUser.id,\n      isAdmin: loadedUser.isAdmin,\n      isOwner: loadedUser.isOwner\n    });\n  } catch (error) {\n    if (!error.statusCode) {\n      error.statusCode = 500;\n    }\n    next(error);\n  }\n};\nexports.confirmAccount = async (req, res, next) => {\n  const registryToken = req.body.registryToken;\n  const errors = validationResult(req);\n  try {\n    if (!errors.isEmpty()) {\n      const error = new Error(\"Login failed!\");\n      error.statusCode = 422;\n      error.data = errors.array();\n      throw error;\n    }\n    if (!registryToken) {\n      const error = new Error(\"No token available!\");\n      error.statusCode = 422;\n      throw error;\n    }\n    const user = await User.findOne({\n      registryToken: registryToken\n    });\n    if (!user) {\n      const error = new Error(\"This user does not exist!\");\n      error.statusCode = 422;\n      throw error;\n    }\n    if (Date.parse(user.registryTokenExpiration) / 1000 > Date.now()) {\n      const error = new Error(\"Token expired\");\n      error.statusCode = 401;\n      throw error;\n    }\n    user.registryToken = null;\n    user.registryTokenExpiration = null;\n    await user.save();\n    res.status(200).json({\n      message: \"Account activated\"\n    });\n  } catch (error) {\n    next(error);\n  }\n};\nexports.resetPassword = async (req, res, next) => {\n  const email = req.body.email;\n  const errors = validationResult(req);\n  let resetToken, resetTokenExpiration; // Declare the variables here\n\n  try {\n    if (!errors.isEmpty()) {\n      const error = new Error(\"Reset failed!\");\n      error.statusCode = 422;\n      error.data = errors.array();\n      throw error;\n    }\n    if (!email) {\n      const error = new Error(\"Email is required to trigger password reset.\");\n      error.statusCode = 422;\n      throw error;\n    }\n    const user = await User.findOne({\n      email\n    });\n    if (!user) {\n      const error = new Error(\"This email does not exist.\");\n      error.statusCode = 422;\n      throw error;\n    }\n    const buffer = await crypto.randomBytes(32);\n    resetToken = buffer.toString(\"hex\");\n    resetTokenExpiration = Date.now() + 3600000;\n    user.resetToken = resetToken;\n    user.resetTokenExpiration = resetTokenExpiration;\n    await user.save();\n    res.status(200).json({\n      resetToken: resetToken\n    });\n  } catch (error) {\n    next(error);\n  }\n};\n\n//\"resetToken\": \"0b5bebc47406b7b64bf2425de01b9b43fc1181079202e44a74a7178dab8c4602\"\n\nexports.postNewPassword = async (req, res, next) => {\n  let loadedUser;\n  const errors = validationResult(req);\n  try {\n    const resetToken = req.body.resetToken;\n    const newPassword = req.body.password;\n    const newRepeatPassword = req.body.repeatPassword;\n    const user = await User.findOne({\n      resetToken: resetToken\n    }); //nu merge await fara async\n    if (!errors.isEmpty()) {\n      const error = new Error(\"Reset failed!\");\n      error.statusCode = 422;\n      error.data = errors.array();\n      throw error;\n    }\n    if (!newPassword) {\n      const error = new Error(\"New password is needed\");\n      error.statusCode = 401;\n      throw error;\n    }\n    if (!newRepeatPassword) {\n      const error = new Error(\"New password repeat is needed\");\n      error.statusCode = 401;\n      throw error;\n    }\n    if (newPassword !== newRepeatPassword) {\n      const error = new Error(\"Passwords do not match\");\n      error.statusCode = 401;\n      throw error;\n    }\n\n    // Update the user's password with the new password\n    const hashedNewPassword = await bcrypt.hash(newPassword, 12);\n    user.password = hashedNewPassword;\n\n    // Clear the reset token and expiration\n    user.resetToken = null;\n    user.resetTokenExpiration = null;\n    await user.save();\n    res.status(200).json({\n      message: \"Password was reset succesfully!\"\n    });\n  } catch (error) {\n    next(error);\n  }\n};","map":{"version":3,"names":["User","require","bcrypt","jwt","crypto","validationResult","exports","signup","req","res","next","errors","user","findOne","email","body","isEmpty","error","Error","statusCode","data","array","console","log","status","send","message","buffer","randomBytes","registryToken","toString","registryTokenExpiration","Date","now","name","password","hashedPassword","hash","isAdmin","isOwner","save","_id","login","loadedUser","isEqual","compare","token","sign","userId","id","process","env","JWT_KEY","expiresIn","json","confirmAccount","parse","resetPassword","resetToken","resetTokenExpiration","postNewPassword","newPassword","newRepeatPassword","repeatPassword","hashedNewPassword"],"sources":["D:/proiecte/frontend/src/pages/Authentication.js"],"sourcesContent":["const { User } = require(\"../models/user\");\r\nconst bcrypt = require(\"bcryptjs\");//pachet pt criptarea parolei cand inregistrezi userul\r\nconst jwt = require(\"jsonwebtoken\");\r\nconst crypto = require(\"crypto\");\r\nconst { validationResult } = require(\"express-validator\");\r\n\r\nexports.signup = async (req, res, next) => {\r\n  const errors = validationResult(req);\r\n\r\n  try {\r\n\r\n    let user = await User.findOne({ email: req.body.email });\r\n\r\n    if (!errors.isEmpty()) {\r\n      const error = new Error(\"Registration failed!\");\r\n      error.statusCode = 422;\r\n      error.data = errors.array();\r\n      throw error;\r\n    }\r\n\r\n    console.log(user);\r\n    if (user) {\r\n      return res.status(401).send({ message: \"User registered already\" });\r\n    }\r\n\r\n    // if (!req.body.repeatPassword) {\r\n    //     const error = new Error(\"Repeated password cannot be empty\");\r\n    //     error.statusCode = 422;\r\n    //     throw error;\r\n    // }\r\n\r\n    // if (!req.body.password) {\r\n    //     const error = new Error(\"Password cannot be empty\");\r\n    //     error.statusCode = 422;\r\n    //     throw error;\r\n    // }\r\n\r\n\r\n\r\n\r\n\r\n    const buffer = await crypto.randomBytes(32);\r\n    const registryToken = buffer.toString(\"hex\");\r\n    const registryTokenExpiration = Date.now() + 3600000;\r\n\r\n\r\n\r\n    const name = req.body.name;\r\n    const email = req.body.email;\r\n    const password = req.body.password;\r\n\r\n\r\n    const hashedPassword = await bcrypt.hash(password, 12);\r\n    //user = new User({ name: name, email: email, password: password });\r\n    user = new User({\r\n      name: name, email: email, password: hashedPassword, registryToken: registryToken, registryTokenExpiration: registryTokenExpiration, isAdmin: false,\r\n      isOwner: false\r\n    });//pt a pune in baza de date\r\n\r\n    await user.save();//pt a pune in baza de date\r\n\r\n    res.status(200).send(user._id);\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n\r\n};\r\n\r\n\r\n\r\nexports.login = async (req, res, next) => {\r\n  let loadedUser;\r\n  const errors = validationResult(req);\r\n  try {\r\n    const email = req.body.email;\r\n    const password = req.body.password;\r\n\r\n    const user = await User.findOne({ email, registryToken: null },);\r\n    if (!errors.isEmpty()) {\r\n      const error = new Error(\"Login failed!\");\r\n      error.statusCode = 422;\r\n      error.data = errors.array();\r\n      throw error;\r\n    }\r\n\r\n\r\n    if (!user) {\r\n      const error = new Error(\"Email or password incorrect!\");\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n    loadedUser = user;\r\n    const isEqual = await bcrypt.compare(password, user.password);\r\n\r\n    if (!isEqual) {\r\n      const error = new Error(\"Email or password incorrect!\");\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n    const token = jwt.sign(\r\n      {\r\n        email: loadedUser.email,\r\n        userId: loadedUser.id,\r\n      },\r\n      process.env.JWT_KEY,\r\n      { expiresIn: \"1h\" }\r\n    );\r\n\r\n    res.status(200).json({\r\n      token: token,\r\n      userId: loadedUser.id,\r\n      isAdmin: loadedUser.isAdmin,\r\n      isOwner: loadedUser.isOwner,\r\n    });\r\n  } catch (error) {\r\n    if (!error.statusCode) {\r\n      error.statusCode = 500;\r\n    }\r\n\r\n    next(error);\r\n  }\r\n};\r\n\r\n\r\nexports.confirmAccount = async (req, res, next) => {\r\n  const registryToken = req.body.registryToken;\r\n  const errors = validationResult(req);\r\n  try {\r\n    if (!errors.isEmpty()) {\r\n      const error = new Error(\"Login failed!\");\r\n      error.statusCode = 422;\r\n      error.data = errors.array();\r\n      throw error;\r\n    }\r\n\r\n    if (!registryToken) {\r\n      const error = new Error(\"No token available!\");\r\n      error.statusCode = 422;\r\n      throw error;\r\n    }\r\n\r\n    const user = await User.findOne(\r\n      { registryToken: registryToken },\r\n    );\r\n\r\n    if (!user) {\r\n      const error = new Error(\"This user does not exist!\");\r\n      error.statusCode = 422;\r\n      throw error;\r\n    }\r\n\r\n    if (Date.parse(user.registryTokenExpiration) / 1000 > Date.now()) {\r\n      const error = new Error(\"Token expired\");\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n    user.registryToken = null;\r\n    user.registryTokenExpiration = null;\r\n\r\n    await user.save();\r\n    res.status(200).json({\r\n      message: \"Account activated\",\r\n    });\r\n\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nexports.resetPassword = async (req, res, next) => {\r\n  const email = req.body.email;\r\n  const errors = validationResult(req);\r\n  let resetToken, resetTokenExpiration; // Declare the variables here\r\n\r\n  try {\r\n\r\n    if (!errors.isEmpty()) {\r\n      const error = new Error(\"Reset failed!\");\r\n      error.statusCode = 422;\r\n      error.data = errors.array();\r\n      throw error;\r\n    }\r\n    if (!email) {\r\n      const error = new Error(\"Email is required to trigger password reset.\");\r\n      error.statusCode = 422;\r\n      throw error;\r\n    }\r\n\r\n    const user = await User.findOne({ email });\r\n\r\n    if (!user) {\r\n      const error = new Error(\"This email does not exist.\");\r\n      error.statusCode = 422;\r\n      throw error;\r\n    }\r\n\r\n    const buffer = await crypto.randomBytes(32);\r\n    resetToken = buffer.toString(\"hex\");\r\n    resetTokenExpiration = Date.now() + 3600000;\r\n\r\n    user.resetToken = resetToken;\r\n    user.resetTokenExpiration = resetTokenExpiration;\r\n\r\n    await user.save();\r\n\r\n    res.status(200).json({\r\n      resetToken: resetToken\r\n    });\r\n\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\n//\"resetToken\": \"0b5bebc47406b7b64bf2425de01b9b43fc1181079202e44a74a7178dab8c4602\"\r\n\r\nexports.postNewPassword = async (req, res, next) => {\r\n  let loadedUser;\r\n  const errors = validationResult(req);\r\n\r\n  try {\r\n\r\n\r\n    const resetToken = req.body.resetToken;\r\n    const newPassword = req.body.password;\r\n    const newRepeatPassword = req.body.repeatPassword;\r\n\r\n    const user = await User.findOne({ resetToken: resetToken },);//nu merge await fara async\r\n    if (!errors.isEmpty()) {\r\n      const error = new Error(\"Reset failed!\");\r\n      error.statusCode = 422;\r\n      error.data = errors.array();\r\n      throw error;\r\n    }\r\n    if (!newPassword) {\r\n      const error = new Error(\"New password is needed\");\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n    if (!newRepeatPassword) {\r\n      const error = new Error(\"New password repeat is needed\");\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n\r\n    if (newPassword !== newRepeatPassword) {\r\n      const error = new Error(\"Passwords do not match\");\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n\r\n    // Update the user's password with the new password\r\n    const hashedNewPassword = await bcrypt.hash(newPassword, 12);\r\n    user.password = hashedNewPassword;\r\n\r\n    // Clear the reset token and expiration\r\n    user.resetToken = null;\r\n    user.resetTokenExpiration = null;\r\n\r\n    await user.save();\r\n\r\n    res.status(200).json({\r\n      message: \"Password was reset succesfully!\"\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}